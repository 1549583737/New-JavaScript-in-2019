# 防重复提交解决方案

# 传统方式**（不推荐） ** 

首先我们介绍下之前传统的防重复提交方式：  

**1：前端处理： ** 

思路如下：  

function dosubmit(){  

//第一步，我们需要获取表单的提交按钮。  

var btnSubmit = document.getElementById("submit");  

//第二步，需要将表单提交按钮设置为不可用（或则直接隐藏，但是隐藏的话会被认为是BUG），这样就可以避免用户再次点击提交按钮，进行提交操作。  

btnSubmit.disabled= "disabled";  

//第三步，返回true让表单可以正常提交。  

return true;  

}  

**2：服务端session处理 ** 

思路如下：  

1、在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，并在当前用户的Session域中保存这个Token。  

2、将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端。  

3、在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。  





# Spring-AOP防重解决方案（推荐）  

以上是比较早的防重复提交解决方案，本文我们再介绍一种：  

**服务端Spring -AOP防重 ** 

思路如下：  

1、自定义注解 @NoRepeatSubmit 标记有必要防重复提交请求Controller。  



2、通过Spring-AOP方式对所有标记了 @NoRepeatSubmit 的方法进行切入拦截。  



3、在业务方法执行前，获取当前用户的 token+ 当前请求地址，作为一个唯一 KEY，去获取 Redis 分布式锁（如果此时并发获取，只有一个线程会被成功获取到锁）。  



4、业务方法执行后，一定要释放锁，异常也要释放锁（放到finally中释放亦可）。  